C51 COMPILER V9.56.0.0   USART                                                             04/16/2020 22:04:48 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE USART
OBJECT MODULE PLACED IN .\Objects\USART.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil5\C51\BIN\C51.EXE stc_lib\USART.C OPTIMIZE(8,SPEED) BROWSE INCDIR(.\stc_
                    -lib) DEBUG OBJECTEXTEND PRINT(.\Listings\USART.lst) TABS(2) OBJECT(.\Objects\USART.obj)

line level    source

   1          #include "USART.h"
   2          
   3          COMx_Define COM2,COM4;
   4          u8  xdata TX2_Buffer[COM_TX2_Lenth];  //发送缓冲
   5          u8  xdata RX2_Buffer[COM_RX2_Lenth];  //接收缓冲
   6          u8  xdata TX4_Buffer[COM_TX4_Lenth];  //发送缓冲
   7          u8  xdata RX4_Buffer[COM_RX4_Lenth];  //接收缓冲
   8          
   9          /*******************************************************************/
  10          void TX2_write2buff(u8 dat) //写入发送缓冲，指针+1
  11          {
  12   1        TX2_Buffer[COM2.TX_write] = dat;  //装发送缓冲
  13   1        if(++COM2.TX_write >= COM_TX2_Lenth)  COM2.TX_write = 0;
  14   1      
  15   1        if(COM2.B_TX_busy == 0)   //空闲
  16   1        {  
  17   2          COM2.B_TX_busy = 1;   //标志忙
  18   2          SET_TI2();        //触发发送中断
  19   2        }
  20   1      }
  21          
  22          void PrintString2(u8 *puts)
  23          {
  24   1          for (; *puts != 0;  puts++)  TX2_write2buff(*puts);   //遇到停止符0结束
  25   1      }
  26          void TX4_write2buff(u8 dat) //写入发送缓冲，指针+1
  27          {
  28   1        TX4_Buffer[COM4.TX_write] = dat;  //装发送缓冲
  29   1        if(++COM4.TX_write >= COM_TX4_Lenth)  COM4.TX_write = 0;
  30   1      
  31   1        if(COM4.B_TX_busy == 0)   //空闲
  32   1        {  
  33   2          COM4.B_TX_busy = 1;   //标志忙
  34   2          SET_TI4();        //触发发送中断
  35   2        }
  36   1      }
  37          
  38          
  39          void PrintString4(u8 *puts)
  40          {
  41   1          for (; *puts != 0;  puts++)  TX4_write2buff(*puts);   //遇到停止符0结束
  42   1      }
  43          
  44          void USART2_Config(void)    //115200bps@22.1184MHz
  45          {
  46   1        S2CON = 0x50;   //8位数据,可变波特率
  47   1        AUXR |= 0x04;   //定时器2时钟为Fosc,即1T
  48   1        T2L = 0xD0;   //设定定时初值
  49   1        T2H = 0xFF;   //设定定时初值
  50   1        AUXR |= 0x10;   //启动定时器2
  51   1        
  52   1        COM2.id = 2;
  53   1        COM2.TX_read    = 0;
  54   1        COM2.TX_write   = 0;
C51 COMPILER V9.56.0.0   USART                                                             04/16/2020 22:04:48 PAGE 2   

  55   1        COM2.B_TX_busy  = 0;
  56   1        COM2.RX_Cnt     = 0;
  57   1        COM2.RX_TimeOut = 0;
  58   1        COM2.B_RX_EN    = 0;
  59   1        COM2.B_RX_OK    = 0;
  60   1      }
  61          
  62          void USART4_Config(void)    //115200bps@22.1184MHz
  63          {
  64   1        S4CON = 0x10;   //8???,?????
  65   1        S4CON |= 0x40;    //??4?????4???????
  66   1        T4T3M |= 0x20;    //???4???Fosc,?1T
  67   1        T4L = 0xD0;   //??????
  68   1        T4H = 0xFF;   //??????
  69   1        T4T3M |= 0x80;    //?????4
  70   1      
  71   1        COM4.id = 4;
  72   1        COM4.TX_read    = 0;
  73   1        COM4.TX_write   = 0;
  74   1        COM4.B_TX_busy  = 0;
  75   1        COM4.RX_Cnt     = 0;
  76   1        COM4.RX_TimeOut = 0;
  77   1        COM4.B_RX_EN    = 0;
  78   1        COM4.B_RX_OK    = 0;
  79   1      
  80   1      }
  81          
  82          /********************* UART4中断函数************************/
  83          void UART2_int (void) interrupt UART2_VECTOR
  84          {
  85   1        if(RI2)
  86   1        {
  87   2          CLR_RI2();
  88   2          if(COM2.B_RX_EN == 1)
  89   2          {
  90   3            if(COM2.RX_Cnt >= COM_RX2_Lenth)  COM2.RX_Cnt = 0;
  91   3            RX2_Buffer[COM2.RX_Cnt++] = S2BUF;
  92   3            COM2.RX_TimeOut = TimeOutSet2;
  93   3          }
  94   2        }
  95   1      }
  96          
  97          void UART4_int (void) interrupt UART4_VECTOR
  98          {
  99   1        if(RI4)
 100   1        {
 101   2          CLR_RI4();
 102   2          if(COM4.B_RX_EN == 1)
 103   2          {
 104   3            if(COM4.RX_Cnt >= COM_RX2_Lenth)  COM4.RX_Cnt = 0;
 105   3            RX4_Buffer[COM4.RX_Cnt++] = S4BUF;
 106   3            COM4.RX_TimeOut = TimeOutSet4;
 107   3          }
 108   2        }
 109   1      
 110   1        if(TI4)
 111   1        {
 112   2          CLR_TI4();
 113   2          if(COM4.TX_read != COM4.TX_write)
 114   2          {
 115   3            S4BUF = TX4_Buffer[COM4.TX_read];
 116   3            if(++COM4.TX_read >= COM_TX4_Lenth)   COM4.TX_read = 0;
C51 COMPILER V9.56.0.0   USART                                                             04/16/2020 22:04:48 PAGE 3   

 117   3          }
 118   2          else  COM4.B_TX_busy = 0;
 119   2        }
 120   1      
 121   1      }
 122          
 123          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    382    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   2304    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     18    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
