C51 COMPILER V9.56.0.0   TASK                                                              08/02/2020 18:41:03 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE TASK
OBJECT MODULE PLACED IN .\Objects\task.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil5\C51\BIN\C51.EXE APP\task.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\STC
                    -_LIB;.\APP) DEBUG OBJECTEXTEND PRINT(.\Listings\task.lst) TABS(2) OBJECT(.\Objects\task.obj)

line level    source

   1          #include "wifi.h"
   2          #include "http_text.h"
   3          #include "string.h"
   4          #include "debug.h"
   5          #include "devices.h"
   6          /***************************************************************************
   7          eap8266作为服务端，接收消息格式:
   8          +IPD,id,length:data, id 为连接的客户端id，length为接收到的字符串长度,data为数据
   9          eap8266作为服务端，接收消息格式:
  10          +IPD,length:length为接收到的字符串长度,data为数据
  11          ***************************************************************************/
  12          #define SERVER_MSG_KEYWORD  "+IPD,"
  13          #define CLIENT_MSG_KEYWORD  "+IPD,"
  14          //服务端判断请求首页关键字
  15          #define HTTP_SERVER_INDEX_KEYWORD   "GET / "    
  16          //服务端判断请求控制页关键字
  17          #define HTTP_SERVER_CONTROL_KEYWORD   "GET /?"    
  18          //客户端判断收到控制信息关键字
  19          #define HTTP_CLIENT_CONTROL_KEYWORD   "control?" 
  20          
  21          
  22          
  23          void task_Server(void)
  24          {
  25   1        u8 *p, *temp;
  26   1        u8 client_id[2];
  27   1        debug(">>>>>>>>>>>>>>>>>>>>task_Server\r\n");
  28   1        //浏览器发送的请求信息会很多，为方便处理
  29   1        //截取第一行到HTTP之前的请求有效信息
  30   1        temp = strstr(WIFI_RBUF, "HTTP");
  31   1        if(temp)
  32   1        {
  33   2          *temp = 0x00;
  34   2          p = strstr(WIFI_RBUF, SERVER_MSG_KEYWORD);    //获取链接的client_id
  35   2          if(p)
  36   2          {
  37   3            p = p + sizeof(SERVER_MSG_KEYWORD)-1;
  38   3            debug_vip(p);
  39   3            client_id[0] = *p;      //
  40   3            client_id[1] = '\0';
  41   3            p = strstr(WIFI_RBUF,  HTTP_SERVER_INDEX_KEYWORD);    //请求首页?
  42   3            if(p)
  43   3            {
  44   4              WIFI_Server_HTTP_Response(client_id, HTTP_Server_Index);  //发送首页
  45   4            }
  46   3            else
  47   3            {
  48   4              p = strstr(WIFI_RBUF, HTTP_SERVER_CONTROL_KEYWORD); //请求控制?
  49   4              if(p)
  50   4              {
  51   5                if(DevicesControl(p) == 1)    //控制外设
  52   5                  WIFI_Server_HTTP_Response(client_id, HTTP_Server_Index);  //成功返回控制页面
  53   5                else
  54   5                  WIFI_Server_HTTP_Response(client_id, "Devices control Fail !!!");   //师范返回信息
C51 COMPILER V9.56.0.0   TASK                                                              08/02/2020 18:41:03 PAGE 2   

  55   5              }
  56   4            }
  57   3          }
  58   2        }
  59   1      }
  60          
  61          void task_Client(void)
  62          {
  63   1        u8 device_para[100];
  64   1        u8 *p;
  65   1         //向服务器发送设备状态http 请求
  66   1        if(WIFI_ClientConnectServer())
  67   1        {
  68   2          device_para[0] = 0;
  69   2          DeviceGetStatus(device_para); //获取设备信息字符串
  70   2          WIFI_Client_HTTP_Request(HTTP_Client_Request_Head1, device_para, HTTP_Client_Request_Head3);
  71   2          if(WIFI_Receive(1000))    //等待服务器响应
  72   2          {
  73   3            p = strstr(WIFI_RBUF, HTTP_CLIENT_CONTROL_KEYWORD); //收到有效控制信息?
  74   3            if(p)
  75   3            {
  76   4              DevicesControl(p);
  77   4            }
  78   3          }
  79   2          else
  80   2          {
  81   3            debug("Server response timeout!\r\n");
  82   3            
  83   3          }
  84   2        }
  85   1      }
  86          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    378    ----
   CONSTANT SIZE    =    120    ----
   XDATA SIZE       =   ----     105
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
