C51 COMPILER V9.56.0.0   WIFI                                                              07/23/2020 16:03:46 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE WIFI
OBJECT MODULE PLACED IN .\Objects\wifi.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil5\C51\BIN\C51.EXE APP\wifi.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\STC
                    -_LIB;.\APP) DEBUG OBJECTEXTEND PRINT(.\Listings\wifi.lst) TABS(2) OBJECT(.\Objects\wifi.obj)

line level    source

   1          /*****************************************************************************
   2            * @file:      wifi.c
   3            * @author:    louiswoo
   4            * @version:   V1.0
   5            * @date:  2020-4-17
   6            * @brief: 控制wifi 模块esp8266 ，为上层提供接口
   7          *******************************************************************************/
   8          #include "usart.h"
   9          #include "string.h"
  10          #include "gpio.h"
  11          #include "sys.h"
  12          #include "wifi.h"
  13          #include "http_ap.h"
  14          #define SERVER_ADDR   "119.3.233.56"
  15          #define SERVER_PORT   8000
  16          
  17          #define WIFI_CMD_TIMEOUT_MS 200
  18          #define WIFI_CMD_TRY_TIMES    5
  19          
  20          #define WIFI_SEND_TIMEOUT_MS  500
  21          #define WIFI_SEND_TRY_TIMES 3
  22          
  23          typedef struct  
  24          {
  25            u8 *send;     //命令
  26            u8 *match;      //匹配
  27          }
  28          _t_WIFI_CMD_Info;
  29          
  30          /*****************************************************************************
  31          ESP8266配置变量
  32          *******************************************************************************/
  33          //恢复出厂设置
  34          const _t_WIFI_CMD_Info  CMD_Restore={"AT+RESTORE\r\n", "OK"};                
  35          //##配置ESP8266模块为AP模式，开启wifi热点。
  36          const _t_WIFI_CMD_Info  CMD_APMode={"AT+CWMODE=2\r\n", "OK"};   
  37          //wifi名：ESP8266。密码：123456。4是加密方式。4是信道
  38          const _t_WIFI_CMD_Info  CMD_SSID={"AT+CWSAP=\"AI_Lab\",\"1234567890\",4,4\r\n", "OK"};                
  39          //##重启模块使AP模式生效
  40          const _t_WIFI_CMD_Info  CMD_Reset={"AT+RST\r\n", "OK"};                      
  41          //## 1启动多连接，0关闭
  42          //这里强调一下，ESP8266作为服务器做多支持5个客户端的链接，id分配顺序是0-4。
  43          const _t_WIFI_CMD_Info  CMD_Muti={"AT+CIPMUX=1\r\n", "OK"};                
  44          //##模块开启服务器模式，端口号8080
  45          const _t_WIFI_CMD_Info  CMD_Server={"AT+CIPSERVER=1,5000\r\n", "OK"};        
  46          //##查看一下ESP8266的IP
  47          const _t_WIFI_CMD_Info  CMD_IP={"AT+CIFSR\r\n", "OK"};        
  48          
  49          //ap模式下的发送命令，0连接客户端，170发送字节长度
  50          _t_WIFI_CMD_Info  CMD_Send= {"AT+CIPSEND=0,170\r\n", "OK"};
  51          
  52          
  53          #define WIFI_GPIO_PORT    GPIO_P5
  54          #define WIFI_GPIO_PIN   GPIO_Pin_3
C51 COMPILER V9.56.0.0   WIFI                                                              07/23/2020 16:03:46 PAGE 2   

  55          
  56          #define wifi_reset_pin_low()    GPIO_ClearBit(WIFI_GPIO_PORT, WIFI_GPIO_PIN)
  57          #define wifi_reset_pin_high()   GPIO_SetBit(WIFI_GPIO_PORT, WIFI_GPIO_PIN)
  58          
  59          /*
  60            * @brief: 整形数字转换成字符串函数
  61            * @param: num 要转换的整数，str 转换出来的字符串的存贮控件指针
  62            * @retval:  返回去掉前面的0的整数字符串指针
  63          */
  64          u8 *int_to_str( u8 *str,u16 num)
  65          {
  66   1        u8 *p;
  67   1        str[0] = num/10000+0x30;
  68   1        str[1] = num%10000/1000+0x30;
  69   1        str[2] = num%1000/100+0x30;
  70   1        str[3] = num%100/10+0x30;
  71   1        str[4] = num%10+0x30;
  72   1        str[5] = '\0';
  73   1        p=str;
  74   1        while(*p == '0')
  75   1          p++;
  76   1        if(*p == 0)
  77   1          p++;
  78   1        return p;
  79   1      }
  80          
  81          //esp8266硬件重启
  82          void wifi_reset(void)
  83          {
  84   1        GPIO_InitTypeDef  wifi_gpio_init;
  85   1      
  86   1        wifi_gpio_init.Mode=GPIO_PullUp;
  87   1        wifi_gpio_init.Pin=WIFI_GPIO_PIN;
  88   1        
  89   1        GPIO_Inilize(WIFI_GPIO_PORT, &wifi_gpio_init);
  90   1      
  91   1        wifi_reset_pin_low();
  92   1        delay_ms(100);
  93   1        wifi_reset_pin_high();
  94   1        delay_s(2);
  95   1      }
  96          /****************************************************************************************
  97            * @brief: esp8266 串口接收函数，启动接收，以块为单位接收串口信息，
  98                调用函数以后，如果TimeOutSet2*(ms/tick) 时间内接收不到新字节
  99                接收块结束，返回接收到的字节数，本函数为阻塞函数  
 100                阻塞时间为: 接收块时间+ TimeOutSet2
 101            * @param: none
 102            * @retval:  返回接收到的字节数，接收到的块存在缓存RX2_Buffer
 103          *****************************************************************************************/
 104          u8 wifi_receive()
 105          {
 106   1        COM2.B_RX_EN=1;
 107   1        COM2.RX_Cnt=0;
 108   1        COM2.B_RX_OK=0;
 109   1        COM2.RX_TimeOut=TimeOutSet2;
 110   1        while(COM2.RX_TimeOut>0);     //每次串口接收不到字节产生超时，判定为一次块接收完成
 111   1        COM2.B_RX_EN=0;
 112   1        if(COM2.B_RX_OK)
 113   1        {
 114   2          return COM2.RX_Cnt;
 115   2        }
 116   1        return NULL;
C51 COMPILER V9.56.0.0   WIFI                                                              07/23/2020 16:03:46 PAGE 3   

 117   1      }
 118          
 119          
 120          /****************************************************************************************
 121            * @brief: 给esp8266 发送命令，并匹配缓冲区当中的字符        
 122            * @param: send: 要发送的命令
 123                match:  要匹配的字符串
 124                timeout_ticks:  设置超时的时间ms
 125            * @retval:  如果在超时时间内收到多条消息，每条消息都与match 匹配，
 126                  成功立即返回1，超时则返回0
 127          *****************************************************************************************/
 128          
 129          u8 WIFI_SendAndWait(u8 *send, u8 *match, u16 timeout_ms)
 130          {
 131   1        u8 *p;
 132   1        u8 i;
 133   1        Usart2SendString(send);     //发送命令
 134   1        for(i = timeout_ms/(TimeOutSet2 * MS_PER_TICK); i>0; i--)   //计算超时次数
 135   1        {
 136   2          if(wifi_receive())      //等待块消息
 137   2          {
 138   3            debug(RX2_Buffer);
 139   3            if(p=strstr(RX2_Buffer,match))
 140   3            {
 141   4              debug_vip("match");
 142   4              return 1;
 143   4            }
 144   3          }
 145   2        }
 146   1        return 0;
 147   1      }
 148          /****************************************************************************************
 149            * @brief: 客户端连接 发送函数，先发送准备发送的命令，AT+CIPSEND=clientid,length ，
 150                  参数是client的号（0-4），和发送数据的长度，然后才是内容，
 151                  如果length大于实际发送的数据长度，则此次发送不发生，
 152                  如果length小于实际发送的长度，则此次发送length长度的数据，多余的数据截断丢失
 153            * @param: client_id，连接的客户端id， p发送内容指针
 154            * @retval:  成功返回1，失败0
 155          *****************************************************************************************/
 156          u8 send_to_client(u8 *client_id, u8 *p)
 157          {
 158   1        u8 temp[6];
 159   1        u8 cmd[30]="AT+CIPSEND=";
 160   1        u8 *str;
 161   1        u16 send_len = strlen(p);
 162   1        strcat(cmd, client_id);       //组合客户端id
 163   1        strcat(cmd, ",");
 164   1        str = int_to_str(temp, send_len);
 165   1        strcat(cmd, str);         //组合长度
 166   1        strcat(cmd, "\r\n");
 167   1      
 168   1        if( !WIFI_SendAndWait(cmd, "> ", WIFI_CMD_TIMEOUT_MS ))   //发送发送命令
 169   1          return FAIL;
 170   1        if( !WIFI_SendAndWait(p, "SEND OK", WIFI_SEND_TIMEOUT_MS))      //发送内容
 171   1          return FAIL;
 172   1      
 173   1        return SUCCESS;
 174   1      }
 175          /****************************************************************************************
 176            * @brief: http送函数，先发送发送http 头，然后是content_length，最后content
 177            * @param: client_id，连接的客户端id， p发送内容指针
 178            * @retval:  成功返回1，失败0
C51 COMPILER V9.56.0.0   WIFI                                                              07/23/2020 16:03:46 PAGE 4   

 179          *****************************************************************************************/
 180          u8 http_send(u8 *client_id, u8 *content)
 181          {
 182   1        u8 http_content_lenth_string[10];
 183   1        u8 temp[6];
 184   1        u8 *p;
 185   1        u16 content_size = strlen(content);
 186   1        
 187   1        memset(http_content_lenth_string, 0, sizeof(http_content_lenth_string));
 188   1        if(!send_to_client(client_id, HTTP_H1) )    //发送http 头，不包括content_length
 189   1          return FAIL;
 190   1        
 191   1        p = int_to_str( temp, content_size);      //发送content_length和两个换行符
 192   1        strcat(http_content_lenth_string, p);
 193   1        strcat(http_content_lenth_string,"\r\n\r\n");
 194   1        if(!send_to_client(client_id, http_content_lenth_string))
 195   1          return FAIL;
 196   1        
 197   1        if(!send_to_client(client_id, content))   //发送内容
 198   1          return FAIL;
 199   1        return SUCCESS;
 200   1      
 201   1      }
 202          
 203          
 204          
 205          u8 WIFI_Set_AP_mode(void)
 206          {
 207   1        if( !WIFI_SendAndWait(CMD_APMode.send, CMD_APMode.match, WIFI_CMD_TIMEOUT_MS))
 208   1          return FAIL;
 209   1        if( !WIFI_SendAndWait(CMD_SSID.send, CMD_SSID.match, WIFI_CMD_TIMEOUT_MS ))
 210   1        {
 211   2          delay_s(2);
 212   2          return FAIL;
 213   2        }
 214   1        if( !WIFI_SendAndWait(CMD_Reset.send, CMD_Reset.match, WIFI_CMD_TIMEOUT_MS ))
 215   1          return FAIL;
 216   1        delay_s(2);
 217   1        if( !WIFI_SendAndWait(CMD_Muti.send, CMD_Muti.match, WIFI_CMD_TIMEOUT_MS ))
 218   1          return FAIL;
 219   1        if( !WIFI_SendAndWait(CMD_Server.send, CMD_Server.match, WIFI_CMD_TIMEOUT_MS ))
 220   1          return FAIL;
 221   1        if( !WIFI_SendAndWait(CMD_IP.send, CMD_IP.match, WIFI_CMD_TIMEOUT_MS ))
 222   1          return FAIL;
 223   1        return SUCCESS;
 224   1      }
 225          
 226          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1206    ----
   CONSTANT SIZE    =    199    ----
   XDATA SIZE       =     48      93
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
