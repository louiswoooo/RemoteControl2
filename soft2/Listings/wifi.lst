C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE WIFI
OBJECT MODULE PLACED IN .\Objects\wifi.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil5\C51\BIN\C51.EXE APP\wifi.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\STC
                    -_LIB;.\APP) DEBUG OBJECTEXTEND PRINT(.\Listings\wifi.lst) TABS(2) OBJECT(.\Objects\wifi.obj)

line level    source

   1          /*****************************************************************************
   2            * @file:      wifi.c
   3            * @author:    louiswoo
   4            * @version:   V1.0
   5            * @date:  2020-4-17
   6            * @brief: 控制wifi 模块esp8266 ，为上层提供接口
   7          *******************************************************************************/
   8          #include "usart.h"
   9          #include "string.h"
  10          #include "gpio.h"
  11          #include "sys.h"
  12          #include "wifi.h"
  13          #include "http_text.h"
  14          
  15          #define WIFI_CMD_TIMEOUT_MS 3000
  16          #define WIFI_CMD_TRY_TIMES    5
  17          
  18          #define WIFI_SEND_TIMEOUT_MS  3000
  19          #define WIFI_SEND_TRY_TIMES 3
  20          
  21          #define SERVER_RESPONSE_BLOCK_SIZE  1800
  22          
  23          typedef struct  
  24          {
  25            u8 *send;     //命令
  26            u8 *match;      //匹配
  27          }
  28          _t_WIFI_CMD_Info;
  29          
  30          /*****************************************************************************
  31          设置ESP8266 服务端模式命令和答复关键字
  32          连接流程:设置AP模式-设置ssid和密码-重启-设置多链接-开启服务器-查看ip
  33          *******************************************************************************/
  34          //恢复出厂设置
  35          const _t_WIFI_CMD_Info  CMD_Restore={"AT+RESTORE\r\n", "OK"};                
  36          //##配置ESP8266模块为AP模式，开启wifi热点。
  37          const _t_WIFI_CMD_Info  CMD_APMode={"AT+CWMODE=2\r\n", "OK"};   
  38          //wifi名：ESP8266。密码：123456。4是加密方式。4是信道
  39          const _t_WIFI_CMD_Info  CMD_SSID={"AT+CWSAP=\"AI_Lab\",\"1234567890\",4,4\r\n", "OK"};                
  40          //##重启模块使AP模式生效
  41          const _t_WIFI_CMD_Info  CMD_Reset={"AT+RST\r\n", "OK"};                      
  42          //## 1启动多连接，0关闭
  43          //这里强调一下，ESP8266作为服务器做多支持5个客户端的链接，id分配顺序是0-4。
  44          const _t_WIFI_CMD_Info  CMD_Muti={"AT+CIPMUX=1\r\n", "OK"};                
  45          //##模块开启服务器模式，端口号8080
  46          const _t_WIFI_CMD_Info  CMD_Server={"AT+CIPSERVER=1,5000\r\n", "OK"};        
  47          //##查看一下ESP8266的IP
  48          const _t_WIFI_CMD_Info  CMD_IP={"AT+CIFSR\r\n", "OK"};        
  49          
  50          
  51          /*****************************************************************************
  52          设置ESP8266 客户端 模式命令和答复关键字
  53          连接流程:设置STA模式-重启-连接wifi-开启单链接-建立TCP连接
  54          *******************************************************************************/
C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 2   

  55          //##配置ESP8266模块为Station 模式，开启wifi热点。
  56          const _t_WIFI_CMD_Info  CMD_STAMode={"AT+CWMODE=1\r\n", "OK"};   
  57          //连接路由器，wifi名：HiTV_woo。密码：1234567890。
  58          const _t_WIFI_CMD_Info  CMD_Connect_WIFI={"AT+CWJAP=\"HiTV_woo_plus\",\"1234567890\"\r\n", "OK"};          
             -      
  59          //开启单链接
  60          const _t_WIFI_CMD_Info  CMD_Single={"AT+CIPMUX=0\r\n", "OK"};                
  61          //建立TCP 连接
  62          const _t_WIFI_CMD_Info  CMD_Connect_Server={"AT+CIPSTART=\"TCP\",\"192.168.1.106\",5000\r\n", "OK"};       
             - 
  63          //关闭TCP 连接
  64          const _t_WIFI_CMD_Info  CMD_Disconnect_Server={"AT+CIPCLOSE=0\r\n", "OK"};        
  65          
  66          #define WIFI_GPIO_PORT    GPIO_P5
  67          #define WIFI_GPIO_PIN   GPIO_Pin_3
  68          
  69          #define wifi_reset_pin_low()    GPIO_ClearBit(WIFI_GPIO_PORT, WIFI_GPIO_PIN)
  70          #define wifi_reset_pin_high()   GPIO_SetBit(WIFI_GPIO_PORT, WIFI_GPIO_PIN)
  71          
  72          /*****************************************************************************
  73            * @brief: 整形数字转换成字符串函数
  74            * @param: num 要转换的整数，str 转换出来的字符串的存贮控件指针
  75            * @retval:  返回去掉前面的0的整数字符串指针
  76          *******************************************************************************/
  77          u8 *int_to_str( u8 *str,u16 num)
  78          {
  79   1        u8 *p;
  80   1        str[0] = num/10000+0x30;
  81   1        str[1] = num%10000/1000+0x30;
  82   1        str[2] = num%1000/100+0x30;
  83   1        str[3] = num%100/10+0x30;
  84   1        str[4] = num%10+0x30;
  85   1        str[5] = '\0';
  86   1        p=str;
  87   1        while(*p == '0')
  88   1          p++;
  89   1        if(*p == 0)
  90   1          p++;
  91   1        return p;
  92   1      }
  93          
  94          /*****************************************************************************
  95            * @brief: esp 8266 硬件重启，需要给它一个低电平，然后延时进入控制
  96            * @param: num 要转换的整数，str 转换出来的字符串的存贮控件指针
  97            * @retval:  返回去掉前面的0的整数字符串指针
  98          *******************************************************************************/
  99          void WIFI_Reset(void)
 100          {
 101   1        GPIO_InitTypeDef  wifi_gpio_init;
 102   1      
 103   1        wifi_gpio_init.Mode=GPIO_PullUp;
 104   1        wifi_gpio_init.Pin=WIFI_GPIO_PIN;
 105   1        
 106   1        GPIO_Inilize(WIFI_GPIO_PORT, &wifi_gpio_init);
 107   1      
 108   1        wifi_reset_pin_low();
 109   1        delay_ms(100);
 110   1        wifi_reset_pin_high();
 111   1        delay_s(2);
 112   1      }
 113          /****************************************************************************************
 114            * @brief: esp8266 串口接收函数，启动接收，以块为单位接收串口信息，
C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 3   

 115                调用函数以后，每次以(TimeOutSet2* MS_PER_TICK) 时间接收串口信息，
 116                如果收到则返回，如果等待timeout_ms 时间仍然没有收到一个字节
 117                函数则超时返回
 118                其中COM2.RX_TimeOut 为块接收超时计数器，每个tick 中断会-1
 119            * @param: timeout_ms, wifi 接收的超时时间
 120            * @retval:  返回接收到的字节数，接收到的块存在缓存RX2_Buffer
 121          *****************************************************************************************/
 122          u8 WIFI_Receive(u16 timeout_ms) 
 123          {
 124   1        u16 i;
 125   1        if(timeout_ms > 0)
 126   1        {
 127   2          for(i= timeout_ms/(TimeOutSet2* MS_PER_TICK); i>0; i--)   //计算在timeout_ms时间的循环次数
 128   2          {
 129   3            COM2.B_RX_EN=1;   //设置允许接收
 130   3            COM2.RX_Cnt=0;      //清零接收计数器
 131   3            COM2.B_RX_OK=0;   //清零接收标志
 132   3            COM2.RX_TimeOut=TimeOutSet2;  //设置块接收时间
 133   3            while(COM2.RX_TimeOut>0);     //如果块接收超时时间未到，继续等待
 134   3            COM2.B_RX_EN=0;     //超时时间到，停止接收
 135   3            if(COM2.B_RX_OK)      //如果收到字节
 136   3            {
 137   4              return COM2.RX_Cnt; //返回字节
 138   4            }
 139   3          }
 140   2        }
 141   1        return NULL;
 142   1      }
 143          
 144          
 145          /****************************************************************************************
 146            * @brief: 给esp8266 发送信息，并匹配缓冲区当中的字符
 147                  等待timeout_ms 如果收到匹配则返回1，否则返回0
 148            * @param: send: 要发送的命令
 149                match:  要匹配的字符串
 150                timeout_ms: 设置超时的时间ms
 151            * @retval:  如果在超时时间内收到多条消息，每条消息都与match 匹配，
 152                  成功立即返回1，超时则返回0
 153          *****************************************************************************************/
 154          u8 wifi_send_and_wait(u8 *send, u8 *match, u16 timeout_ms)
 155          {
 156   1        u8 *p;
 157   1        u16 i;
 158   1        
 159   1        Usart2SendString(send);     //发送消息
 160   1        for(i = (timeout_ms/TimeOutSet2) / MS_PER_TICK; i>0; i--)   
 161   1        {
 162   2          if(WIFI_Receive(TimeOutSet2 * MS_PER_TICK))     //等待块消息
 163   2          {
 164   3            debug(RX2_Buffer);
 165   3            if(p=strstr(RX2_Buffer,match))
 166   3            {
 167   4              debug_vip("match");
 168   4              return 1;
 169   4            }
 170   3          }
 171   2        }
 172   1        return 0;
 173   1      }
 174          
 175          /****************************************************************************************
 176            * @brief: esp8266作为服务端的http response 函数，收到http请求以后，
C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 4   

 177                  调用该函数进行response (参看HTTP 协议)
 178                  分成3部分发送，先发送http 头，然后是content_length，最后content
 179            * @param: client_id，连接的客户端id， p发送内容指针
 180            * @retval:  成功返回1，失败0
 181          *****************************************************************************************/
 182          u8 WIFI_Server_HTTP_Response(u8 *client_id, u8 *content)
 183          {
 184   1        u16 i;
 185   1        u8 temp[6];
 186   1        u8 response_head2[12];
 187   1        u8 cmd[30]="AT+CIPSEND="; //发送命令
 188   1        u8 *str;
 189   1        u16 len, content_size;  
 190   1        u8 *p;
 191   1      
 192   1        content_size = strlen(content);
 193   1        //发送h1+h2
 194   1        int_to_str(response_head2, content_size);
 195   1        strcat(response_head2, "\r\n\r\n");
 196   1        len = strlen(HTTP_Server_Response_Head1) + strlen(response_head2);  //计算长度
 197   1        str = int_to_str(temp, len);    //转换成长度字符
 198   1        strcat(cmd, client_id);
 199   1        strcat(cmd, ",");
 200   1        strcat(cmd, str);         //组合长度
 201   1        strcat(cmd, "\r\n");
 202   1        if(!wifi_send_and_wait(cmd, "> ", WIFI_CMD_TIMEOUT_MS ))  //发送发送命令，等待回应
 203   1          return FAIL;
 204   1        Usart2SendString(HTTP_Server_Response_Head1);
 205   1        Usart2SendString(response_head2);
 206   1        //发送content
 207   1        for(i = content_size/SERVER_RESPONSE_BLOCK_SIZE;i>0;i--)
 208   1        {
 209   2          str = int_to_str(temp, SERVER_RESPONSE_BLOCK_SIZE);   //转换成长度字符
 210   2          strcat(cmd, client_id);
 211   2          strcat(cmd, ",");
 212   2          strcat(cmd, str);         //组合长度
 213   2          strcat(cmd, "\r\n");
 214   2          if(!wifi_send_and_wait(cmd, "> ", WIFI_CMD_TIMEOUT_MS ))  //发送发送命令，等待回应
 215   2            return FAIL;
 216   2          TX2_write2buff(*p);
 217   2          p++;
 218   2          if(!wifi_send_and_wait(NULL, "SEND OK", WIFI_SEND_TIMEOUT_MS))
 219   2            return FAIL;
 220   2        }
 221   1        //发送结尾
 222   1        p++;
 223   1        if(!wifi_send_and_wait(p, "SEND OK", WIFI_SEND_TIMEOUT_MS))
 224   1          return FAIL;
 225   1        return SUCCESS;
 226   1      
 227   1      }
 228          /****************************************************************************************
 229            * @brief: esp8266作为客户端的http request 函数，发送服务器http请求
 230                  调用该函数进行request (参看HTTP 协议)
 231                  分成4部分发送:
 232                  1. 发送http 头前导,例如: GET /a11?
 233                  2. 发送请求参数SWITH1=ON&SWITCH2=OFF&xxxx，
 234                  3. 发送头剩余信息
 235                  4. 发送步骤2的参数
 236            * @param: h1 http 头前导, para http参数，h3头部剩余
 237            * @retval:  成功返回1，失败0
 238          *****************************************************************************************/
C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 5   

 239          u8 WIFI_Client_HTTP_Request(u8 *h1, u8 *para, u8 *h3)
 240          {
 241   1        u8 temp[6];
 242   1        u8 cmd[30]="AT+CIPSEND="; //发送命令
 243   1        u8 *str;
 244   1        u16 request_len = strlen(h1) + strlen(para)*2 + strlen(h3) ;  //计算长度
 245   1        str = int_to_str(temp, request_len);    //转换成长度字符
 246   1        strcat(cmd, str);         //组合长度
 247   1        strcat(cmd, "\r\n");
 248   1      
 249   1        if(!wifi_send_and_wait(cmd, "> ", WIFI_CMD_TIMEOUT_MS ))  //发送发送命令，等待回应
 250   1          return FAIL;
 251   1        Usart2SendString(h1); //发送头部1
 252   1        Usart2SendString(para); //发送参数
 253   1        Usart2SendString(h3); //发送头部3
 254   1        if(!wifi_send_and_wait(para, "SEND OK", WIFI_CMD_TIMEOUT_MS ))    //发送参数，并等待发送完成
 255   1          return FAIL;
 256   1        debug_vip("SEND OK");
 257   1        return SUCCESS;
 258   1      }
 259          /*********************************************************************************
 260          设置esp8266 为服务器模式，发个wifi热点，连接后可以进行本地控制和设置
 261          连接流程:设置AP模式-设置ssid和密码-重启-设置多链接-开启服务器-查看ip
 262          *******************************************************************************/
 263          u8 WIFI_SetServerMode(void)
 264          {
 265   1        //设置为AP模式
 266   1        if( !wifi_send_and_wait(CMD_APMode.send, CMD_APMode.match, WIFI_CMD_TIMEOUT_MS))
 267   1          return FAIL;
 268   1        //设置wifi 热点信息
 269   1        if( !wifi_send_and_wait(CMD_SSID.send, CMD_SSID.match, WIFI_CMD_TIMEOUT_MS ))
 270   1        {
 271   2          return FAIL;
 272   2        }
 273   1        //重启
 274   1        if( !wifi_send_and_wait(CMD_Reset.send, CMD_Reset.match, WIFI_CMD_TIMEOUT_MS ))
 275   1          return FAIL;
 276   1        delay_s(2);   //重启等待
 277   1        //设置多连接，服务器模式必须设置为多连接
 278   1        if( !wifi_send_and_wait(CMD_Muti.send, CMD_Muti.match, WIFI_CMD_TIMEOUT_MS ))
 279   1          return FAIL;
 280   1        //设置服务器模式和端口
 281   1        if( !wifi_send_and_wait(CMD_Server.send, CMD_Server.match, WIFI_CMD_TIMEOUT_MS ))
 282   1          return FAIL;
 283   1        //查看ip
 284   1        if( !wifi_send_and_wait(CMD_IP.send, CMD_IP.match, WIFI_CMD_TIMEOUT_MS ))
 285   1          return FAIL;
 286   1        return SUCCESS;
 287   1      }
 288          /*****************************************************************************
 289          设置ESP8266 客户端 模式命令和答复关键字
 290          连接流程:设置STA模式-重启-连接wifi-开启单链接
 291          *******************************************************************************/
 292          u8 WIFI_SetClientMode(void)
 293          {
 294   1        //设置为station 模式
 295   1        if( !wifi_send_and_wait(CMD_STAMode.send, CMD_STAMode.match, WIFI_CMD_TIMEOUT_MS))
 296   1          return FAIL;
 297   1        if( !wifi_send_and_wait(CMD_Reset.send, CMD_Reset.match, WIFI_CMD_TIMEOUT_MS ))
 298   1          return FAIL;
 299   1        delay_s(2);
 300   1        //连接wifi，注意wifi连接用时较长，所以给了较长超时时间
C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 6   

 301   1        if( !wifi_send_and_wait(CMD_Connect_WIFI.send, CMD_Connect_WIFI.match, 20000 )) 
 302   1        {
 303   2          return FAIL;
 304   2        }
 305   1        //设置为单连接模式
 306   1        if( !wifi_send_and_wait(CMD_Single.send, CMD_Single.match, WIFI_CMD_TIMEOUT_MS ))
 307   1          return FAIL;
 308   1        return SUCCESS;
 309   1      }
 310          /*****************************************************************************
 311            * @brief: 客户端模式下连接服务器
 312                连接命令: AT+CIPSTART="TCP","192.168.1.106",5000\r\n
 313            * @param: ip 连接的服务器ip , port 服务器端口
 314            * @retval:  成功返回1，失败0
 315          *******************************************************************************/
 316          u8 WIFI_ClientConnectServer(u8 *ip, u8 *port)
 317          {
 318   1        u8 cmd[50] = {"AT+CIPSTART=\"TCP\",\""};
 319   1        strcat(cmd, ip);
 320   1        strcat(cmd, "\",");
 321   1        strcat(cmd, port);
 322   1        strcat(cmd, "\r\n");
 323   1        if( !wifi_send_and_wait(cmd, "CONNECT", 10000 ))
 324   1          return FAIL;
 325   1        return SUCCESS;
 326   1      }
 327          
 328          /****************************************************************************************
 329            * @brief: esp8266作为服务端向连接的客户端发送函数，格式如下:
 330                  AT+CIPSEND=clientid,length    //client 连接的客户端id，length 发送的数据长度
 331                  OK
 332                  >xxxxxxx        //发送的数据
 333                  busy s...
 334                  Recv xx bytes
 335                  SEND OK
 336                  
 337                  如果length大于实际发送的数据长度，则此次发送不发生，
 338                  如果length小于实际发送的长度，则此次发送length长度的数据，多余的数据截断丢失
 339            * @param: client_id，连接的客户端id， p发送内容指针
 340            * @retval:  成功返回1，失败0
 341          *****************************************************************************************
 342          u8 server_send_to_client(u8 *client_id, u8 *p)
 343          {
 344            u8 temp[6];
 345            u8 cmd[30]="AT+CIPSEND=";
 346            u8 *str;
 347            u16 send_len = strlen(p);
 348            strcat(cmd, client_id);       //组合客户端id
 349            strcat(cmd, ",");
 350            str = int_to_str(temp, send_len);
 351            strcat(cmd, str);         //组合长度
 352            strcat(cmd, "\r\n");
 353          
 354            if( !wifi_send_and_wait(cmd, "> ", WIFI_CMD_TIMEOUT_MS ))   //发送发送命令
 355              return FAIL;
 356            if( !wifi_send_and_wait(p, "SEND OK", WIFI_SEND_TIMEOUT_MS))      //发送内容
 357              return FAIL;
 358          
 359            return SUCCESS;
 360          }
 361          ****************************************************************************************
 362            * @brief: esp8266作为客户端向连接的服务端发送函数，格式如下:
C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 7   

 363                  AT+CIPSEND=length   //length 发送的数据长度
 364                  OK
 365                  >xxxxxxx        //发送的数据
 366                  busy s...
 367                  Recv xx bytes
 368                  SEND OK
 369                  
 370                  如果length大于实际发送的数据长度，则此次发送不发生，
 371                  如果length小于实际发送的长度，则此次发送length长度的数据，多余的数据截断丢失
 372            * @param: p发送内容指针
 373            * @retval:  成功返回1，失败0
 374          ****************************************************************************************
 375          u8 client_send_to_server( u8 *p)
 376          {
 377            u8 temp[6];
 378            u8 cmd[30]="AT+CIPSEND=";
 379            u8 *str;
 380            u16 send_len = strlen(p);
 381            str = int_to_str(temp, send_len);
 382            strcat(cmd, str);         //组合长度
 383            strcat(cmd, "\r\n");
 384          
 385            if( !wifi_send_and_wait(cmd, "> ", WIFI_CMD_TIMEOUT_MS ))   //发送发送命令
 386              return FAIL;
 387            if( !wifi_send_and_wait(p, "SEND OK", WIFI_SEND_TIMEOUT_MS))      //发送内容
 388              return FAIL;
 389          
 390            return SUCCESS;
 391          }
 392          
 393          ****************************************************************************************
 394            * @brief: esp8266作为服务端的http response 函数，收到http请求以后，
 395                  调用该函数进行response (参看HTTP 协议)
 396                  分成3部分发送，先发送http 头，然后是content_length，最后content
 397            * @param: client_id，连接的客户端id， p发送内容指针
 398            * @retval:  成功返回1，失败0
 399          *****************************************************************************************
 400          u8 WIFI_Server_HTTP_Response(u8 *client_id, u8 *content)
 401          {
 402            u8 http_content_lenth_string[10];
 403            u8 temp[6];
 404            u8 *p;
 405            u16 content_size = strlen(content);
 406            
 407            memset(http_content_lenth_string, 0, sizeof(http_content_lenth_string));
 408            if(!server_send_to_client(client_id, HTTP_Server_Response_Head1) )    //发送http 头，不包括content_length
 409              return FAIL;
 410            
 411            p = int_to_str( temp, content_size);      //发送content_length和两个换行符
 412            strcat(http_content_lenth_string, p);
 413            strcat(http_content_lenth_string,"\r\n\r\n");
 414            if(!server_send_to_client(client_id, http_content_lenth_string))
 415              return FAIL;
 416            
 417            if(!server_send_to_client(client_id, content))    //发送内容
 418              return FAIL;
 419            return SUCCESS;
 420          
 421          }
 422          */
 423          /****************************************************************************************
 424            * @brief: esp8266作为客户端向连接的服务端发送函数，格式如下:
C51 COMPILER V9.56.0.0   WIFI                                                              08/10/2020 16:37:35 PAGE 8   

 425                  AT+CIPSEND=length   //length 发送的数据长度
 426                  OK
 427                  >xxxxxxx        //发送的数据
 428                  busy s...
 429                  Recv xx bytes
 430                  SEND OK
 431                  
 432                  如果length大于实际发送的数据长度，则此次发送不发生，
 433                  如果length小于实际发送的长度，则此次发送length长度的数据，多余的数据截断丢失
 434            * @param: p发送内容指针
 435            * @retval:  成功返回1，失败0
 436          ****************************************************************************************
 437          u8 client_send_to_server( u8 *p)
 438          {
 439            u8 temp[6];
 440            u8 cmd[30]="AT+CIPSEND=";
 441            u8 *str;
 442            u16 send_len = strlen(p);
 443            str = int_to_str(temp, send_len);
 444            strcat(cmd, str);         //组合长度
 445            strcat(cmd, "\r\n");
 446          
 447            if( !wifi_send_and_wait(cmd, "> ", WIFI_CMD_TIMEOUT_MS ))   //发送发送命令
 448              return FAIL;
 449            if( !wifi_send_and_wait(p, "SEND OK", WIFI_SEND_TIMEOUT_MS))      //发送内容
 450              return FAIL;
 451          
 452            return SUCCESS;
 453          }
 454          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2044    ----
   CONSTANT SIZE    =    396    ----
   XDATA SIZE       =     72     188
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
